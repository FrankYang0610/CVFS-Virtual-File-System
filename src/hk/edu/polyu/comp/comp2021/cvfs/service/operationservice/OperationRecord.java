package hk.edu.polyu.comp.comp2021.cvfs.service.operationservice;

import hk.edu.polyu.comp.comp2021.cvfs.service.operationservice.operations.FileUnrelatedUndoableOperation;
import hk.edu.polyu.comp.comp2021.cvfs.service.operationservice.operations.UndoableOperation;

import java.util.Stack;

/**
 * <h3>The {@code OperationRecord} Class</h3>
 * This class is used to record the executed operations, helping potential undoes and redoes.
 *
 * @implNote Two stacks are used to record executed operations. If an operation is neither an undo nor a redo (called 'regular' in {@code OperationType} enum), it is pushed into the {@code undo} stack after execution, and the {@code redo} stack is cleared. For an undo operation, the operation at the top of the {@code undo} stack is popped and its inverse operation shall be executed. The inverse operation will be pushed into the {@code redo} stack then. For a redo operation, the operation at the top of the {@code redo} stack is popped and its inverse operation shall be executed. The inverse operation will then be pushed into the {@code undo} stack then, and the redo stack will not be cleared.
 */
public final class OperationRecord {
    private final Stack<UndoableOperation> undo;
    private final Stack<UndoableOperation> redo;

    /**
     * Construct a new {@code OperationRecord} object.
     */
    public OperationRecord() {
        undo = new Stack<>();
        redo = new Stack<>();
    }

    /**
     * This method puts the executed operations into the right stack.
     * <p>
     * If the {@code isUndoOperation()} method of an operation returns {@code false}, then it is not generated by the {@code undo} command, then it should be put into the {@code undo} stack. Or, the operation is generated by the {@code undo} command, and it should be put into the {@code redo} stack.
     *
     * @param o the undoable operation
     * @see UndoableOperation
     */
    public void record(UndoableOperation o) {
        if (!o.isUndoOperation()) {
            undo.push(o);
            if (!o.isRedoOperation()) {
                redo.clear();
            }
        } else {
            redo.push(o);
        }
    }

    /**
     * Get the top element of the {@code undo} stack to do undo operation.
     * @return the top element of the {@code undo} stack.
     * @throws InvalidCommandException if there is no operation to undo.
     */
    public UndoableOperation popForUndo() throws InvalidCommandException {
        if (undo.empty()) {
            throw new InvalidCommandException("No operation to undo.");
        }
        return undo.pop();
    }

    /**
     * Get the top element of the {@code redo} stack to do redo operation.
     * @return the top element of the {@code redo} stack.
     * @throws InvalidCommandException if there is no operation to undo.
     */
    public UndoableOperation popForRedo() throws InvalidCommandException {
        if (redo.empty()) {
            throw new InvalidCommandException("No operation to redo.");
        }
        return redo.pop();
    }

    /**
     * Only clear those undoable operations related to files.
     */
    public void clearFileRelated() {
        Stack<UndoableOperation> temp = new Stack<>();

        while (!undo.empty()) {
            UndoableOperation o = undo.pop();
            if (o instanceof FileUnrelatedUndoableOperation) {
                temp.push(o);
            }
        }
        while (!temp.empty()) {
            undo.push(temp.pop());
        }

        while (!redo.empty()) {
            UndoableOperation o = redo.pop();
            if (o instanceof FileUnrelatedUndoableOperation) {
                temp.push(o);
            }
        }
        while (!temp.empty()) {
            redo.push(temp.pop());
        }
    }

    /**
     * Only clear those undoable operations not-related to files.
     */
    public void clearFileUnrelated() {
        Stack<UndoableOperation> temp = new Stack<>();

        while (!undo.empty()) {
            UndoableOperation o = undo.pop();
            if (!(o instanceof FileUnrelatedUndoableOperation)) {
                temp.push(o);
            }
        }
        while (!temp.empty()) {
            undo.push(temp.pop());
        }

        while (!redo.empty()) {
            UndoableOperation o = redo.pop();
            if (!(o instanceof FileUnrelatedUndoableOperation)) {
                temp.push(o);
            }
        }
        while (!temp.empty()) {
            redo.push(temp.pop());
        }
    }

    /**
     * Clear all recorded undoable operations.
     */
    public void clearAll() {
        undo.clear();
        redo.clear();
    }
}
